package main

import (
	"bytes"
	"html/template"
	"log"
	"strings"
)

var tmpl = `// Code generated by protoc-gen-gapi(github.com/xnzone/gapi/protoc-gen-gapi) version={{ .Version }}). DO NOT EDIT.
// source: {{ .Source }}

package {{ .Package }}

import (
	"context"
	"net/http"

	"github.com/xnzone/gapi/client"
	"github.com/xnzone/gapi/server"
)

{{- range .Services }}

// Client API for {{ .Name }} service 

type {{ .Name }}Service interface {
{{- range .Methods }}
	// {{ .Name }} {{ .Comment }}
	{{ .Name }}(ctx context.Context, in *{{ .RequestType }}, opts ...client.CallOption) (*{{ .ResponseType }}, error)
{{- end -}}
}

type {{ unexport .Name }}Service struct {
	addr string // request addr, begin with http or https
	c client.Client		
}

// New{{ .Name }}Service {{ .Comment }}
func New{{ .Name }}Service(addr string, c client.Client) ({{ .Name }}Service) {
	return &{{ unexport .Name }}Service {
		addr: addr,
		c:    c,
	}
}

{{- range .Methods }}
func (c *{{ unexport .ServiceName }}Service) {{ .Name }}(ctx context.Context, in *{{ .RequestType }}, opts ...client.CallOption) (*{{ .ResponseType }}, error) {
	var req *http.Request
	var err error
	{{ if .HasBody }}
	req, err = client.BuildRequest(ctx, "{{ toUpper .HTTPMethod }}", c.addr, "{{ .RelativePath }}", in, in{{ .Body }})
	{{ else }}
	req, err = client.BuildRequest(ctx, "{{ toUpper .HTTPMethod }}", c.addr, "{{ .RelativePath }}", in, nil)
	{{ end }}
	if err != nil {
		return nil, err
	}
	out := new({{ .ResponseType }})
	if err = client.Call(ctx, c.c, req, out, opts...) ; err != nil {
		return nil, err
	}
	return out, nil
}
{{ end }}

// Server API for {{ .Name }} service 

type {{ .Name }}Handler interface {
{{- range .Methods }}
	// {{ .Name }} {{ .Comment }}
	{{ .Name }}(ctx context.Context, in *{{ .RequestType }}, out *{{ .ResponseType }}) error
{{- end }}
}

func Register{{ .Name }}Handler(srv server.Server, hdlr {{ .Name }}Handler) {
	{{- range .Methods }}
	srv.Resolve("{{ toUpper .HTTPMethod }}", "{{ .RelativePath }}", {{ unexport .Name }}Handle(srv, hdlr))
	{{ end }}
}

{{- range .Methods }}
func {{ unexport .Name }}Handle(srv server.Server, hdlr {{ .ServiceName }}Handler) func(ctx context.Context) {
	fn := func(ctx context.Context, in interface{}, out interface{}) error {
		req := in.(*{{ .RequestType }})
		res := out.(*{{ .ResponseType }})
		return hdlr.Hello(ctx, req, res)	
	}
	in, out := new({{ .RequestType }}), new({{ .ResponseType }})
	return server.Handle(srv, fn, in, out)
}
{{ end -}}

{{ end -}}

`

type ProtoMethod struct {
	HTTPMethod   string
	RelativePath string
	Name         string
	RequestType  string
	ResponseType string
	ServiceName  string
	Comment      string
	HasBody      bool
	Body         string
}

type ProtoService struct {
	Name    string
	Comment string
	Methods []*ProtoMethod
}

type ProtoFile struct {
	Version  string
	Source   string
	Package  string
	Services []*ProtoService
}

func MakeGAPIContent(data *ProtoFile) (bs []byte, err error) {
	var t *template.Template
	t, err = template.New("gapi").Funcs(funcMap).Parse(tmpl)
	if err != nil {
		log.Println("parse tmpl err, ", err)
		return
	}
	b := new(bytes.Buffer)
	if err = t.Execute(b, data); err != nil {
		log.Println("execute tmpl err, ", err)
		return
	}
	bs = b.Bytes()
	return
}

var (
	funcMap = template.FuncMap{
		"unexport":  unexport,
		"equalFold": strings.EqualFold,
		"title":     strings.Title,
		"toLower":   strings.ToLower,
		"toUpper":   strings.ToUpper,
	}
)

// unexport 把首字母转小写
func unexport(s string) string {
	if len(s) == 0 {
		return ""
	}
	return strings.ToLower(s[:1]) + s[1:]
}
