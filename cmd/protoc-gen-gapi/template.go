package main

import (
	"bytes"
	"html/template"
	"log"
)

var tmpl = `// Code generated by protoc-gen-gapi(github.com/xnzone/gapi/protoc-gen-gapi) version={{ .Version }}). DO NOT EDIT.
// source: {{ .Source }}

package {{ .Package }}

import (
	"context"
	"fmt"
	"net/http"
	"net/url"
	"strings"

	"github.com/xnzone/gapi/client"
	"github.com/xnzone/gapi/server"
)

{{- range .Services }}

// Client API for {{ .Name }} service 

type {{ .Name }}Service interface {
{{- range .Methods }}
	// {{ .Name }} {{ .Comment }}
	{{ .Name }}(ctx context.Context, in *{{ .RequestType }}, opts ...client.CallOption) (*{{ .ResponseType }}, error)
{{- end -}}
}

type {{ unexport .Name }}Service struct {
	addr string // request addr, begin with http or https
	c client.Client		
}

// New{{ .Name }}Service {{ .Comment }}
func New{{ .Name }}Service(addr string, c client.Client) ({{ .Name }}Service) {
	return &{{ unexport .Name }}Service {
		addr: addr,
		c:    c,
	}
}

{{- range .Methods }}
func (c *{{ unexport .Name }}Service) {{ .Method }}(ctx context.Context, in *{{ .RequestType }}, opts ...client.CallOption) (*{{ .ResponseType }}, error) {
	var req *http.Request
	var err error
	{{ if .HasBody }}
	req, err = c.buildRequest(ctx, {{ toUpper .HTTPMethod }}, {{ .RelativePath }}, in, in{{ .Body }})
	{{ else }}
	req, err = c.buildRequest(ctx, {{ toUpper .HTTPMethod }}, {{ .RelativePath }}, in, nil)
	{{ end }}
	if err != nil {
		return nil, err
	}
	out := new({{ .ResponseType }})
	if err = client.Call(ctx, c.c, req, out, opts...) ; err != nil {
		return nil, err
	}
	return out, nil
}
{{ end -}}

// Server API for {{ .Name }} service 

type {{ .Name }}Handler interface {
{{- range .Methods }}
	// {{ .Name }} {{ .Comment }}
	{{ .Name }}(ctx context.Context, in *{{ .RequestType }}, out *{{ .ResponseType }}) error
{{- end -}}
}

func Register{{ .Name }}Handler(router server.Router, hdlr {{ .Name }}Handler) {
	{{- range .Methods }}
	router.Resolve({{ toUpper .HTTPMethod }}, {{ .RelativePath }}, {{ unexport .Name }}Handle(router, hdlr))
	{{ end -}}
}

{{- range .Methods }}
func {{ unexport .Name }}Handle(router server.Router, hdlr {{ .ServiceName }}Handler) func(ctx context.Context) {
	return func(ctx context.Context) {
		in := new({{ .RequestType }})
		if err := router.Bind(ctx, in); err != nil {
			router.Result(ctx, http.StatusInternalServerError, err.Error())
			return
		}
		out := new({{ .ResponseType }})
		if err := hdlr.{{ .Name }}(ctx, in, out); err != nil {
			router.Result(ctx, http.StatusInternalServerError, err.Error())
			return
		}
		router.Result(ctx, http.StatusOK, out)
	}
}
{{ end -}}

{{ end -}}

func (c *{{ unexport .Name }}Service) buildRequest(ctx context.Context, httpMethod string, relativePath string, in interface{}, body interface{}) (*http.Request, error) {
	relativePath = fmt.Sprintf("%s%s", c.addr, relativePath)
	header, uri, query, err := client.Parse(ctx, in)
	if err != nil {
		return nil, err
	}
	for k, v := range uri {
		if len(v) != 1 {
			continue
		}
		relativePath = strings.ReplaceAll(relativePath, fmt.Sprintf(":%s", k), v[0])
		relativePath = strings.ReplaceAll(relativePath, fmt.Sprintf("*%s", k), v[0])
	}
	if len(query) > 0 {
		q := url.Values(query).Encode()
		relativePath = fmt.Sprintf("%s?%s", relativePath, q)
	}
	req, err := http.NewRequestWithContext(ctx, httpMethod, relativePath, body)
	if err != nil {
		return nil, err
	}
	for k, v := range header {
		for _, vi := range v {
			req.Header.Add(k, vi)
		}
	}
	return req,nil
}

`

type ProtoMethod struct {
	HTTPMethod   string
	RelativePath string
	Name         string
	RequestType  string
	ResponseType string
	ServiceName  string
	Comment      string
	HasBody      bool
	Body         string
}

type ProtoService struct {
	Name    string
	Comment string
	Methods []*ProtoMethod
}

type ProtoFile struct {
	Version  string
	Source   string
	Package  string
	Services []*ProtoService
}

func MakeGAPIContent(data *ProtoFile) (bs []byte, err error) {
	var t *template.Template
	t, err = template.New("gapi").Parse(tmpl)
	if err != nil {
		log.Println("parse tmpl err, ", err)
		return
	}
	b := new(bytes.Buffer)
	if err = t.Execute(b, data); err != nil {
		log.Println("execute tmpl err, ", err)
		return
	}
	bs = b.Bytes()
	return
}
